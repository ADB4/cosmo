{
  "version": "1.0",
  "quizzes": [
    {
      "id": "week14",
      "title": "Week 14: React Testing Library — Rendering, Queries, and user-event",
      "scope": "RTL philosophy, `render` and `screen`, query variants (`getBy`, `queryBy`, `findBy`, `getAllBy`), query priority (`getByRole` > `getByLabelText` > `getByText` > `getByTestId`), accessible queries and ARIA roles, `user-event` vs. `fireEvent`, `waitFor` and async utilities, `within`, `cleanup`, debugging with `screen.debug()` and `logRoles`.",
      "readings": [
        "RTL: \"Introduction\" and \"Guiding Principles\"",
        "TL: \"About Queries\" (full query priority table)",
        "TL: \"ByRole\" query page",
        "UE: \"Introduction,\" \"Setup,\" and API pages (`click`, `type`, `clear`, `selectOptions`, `keyboard`, `tab`)",
        "KCD: \"Common Mistakes with React Testing Library\"",
        "RTL: \"API\" reference (`render`, `wrapper`, `cleanup`)"
      ],
      "scoring_note": "Wrong answers on T/F and MC are subtracted from right answers. Do not guess. Short answer questions are graded on correctness and conciseness — do not write more than is asked for.",
      "sections": [
        {
          "type": "true_false",
          "count": 72,
          "questions": [
            {
              "id": "TF-1",
              "question": "React Testing Library's guiding principle is: \"Tests should verify internal component state and lifecycle methods to ensure correctness.\"",
              "answer": false,
              "explanation": "RTL's guiding principle is: \"The more your tests resemble the way your software is used, the more confidence they can give you.\" RTL explicitly discourages testing internal state and lifecycle methods, favoring tests that mirror real user interactions.",
              "tags": [
                "rtl-philosophy",
                "foundations"
              ]
            },
            {
              "id": "TF-2",
              "question": "React Testing Library exposes component instance methods and internal state so you can test them directly.",
              "answer": false,
              "explanation": "RTL intentionally does NOT expose component instances or internal state. This is by design — it forces you to test behavior, not implementation.",
              "tags": [
                "rtl-philosophy",
                "foundations"
              ]
            },
            {
              "id": "TF-3",
              "question": "RTL encourages finding elements by their internal component names and prop values, then simulating events by directly invoking handler functions.",
              "answer": false,
              "explanation": "RTL encourages finding elements the way a USER would — by visible text, labels, or ARIA roles — and simulating real user actions (clicking, typing). Finding by component names or invoking handlers directly tests implementation details, which RTL discourages.",
              "tags": [
                "general"
              ]
            },
            {
              "id": "TF-4",
              "question": "The `render` function returns the rendered JSX as a string, which you then parse to find elements.",
              "answer": false,
              "explanation": "`render` renders a React component into a real DOM tree (in jsdom) and returns utility functions for querying the rendered output. It does not return a string — it creates actual DOM nodes that can be queried with RTL's query methods.",
              "tags": [
                "rtl-utilities"
              ]
            },
            {
              "id": "TF-5",
              "question": "The `screen` object must be destructured from the `render` call — it is not available as a standalone import from RTL.",
              "answer": false,
              "explanation": "`screen` IS a standalone import from `@testing-library/react`. It references `document.body` and provides all query methods. Using `screen` directly (instead of destructuring from `render`) is the recommended best practice.",
              "tags": [
                "rtl-queries",
                "rtl-utilities",
                "foundations"
              ]
            },
            {
              "id": "TF-6",
              "question": "Destructuring query methods from `render` (e.g., `const { getByText } = render(...)`) is the recommended best practice over using `screen`.",
              "answer": false,
              "explanation": "Using `screen` (e.g., `screen.getByText(...)`) is the recommended best practice, not destructuring from `render`. Kent C. Dodds lists destructuring from `render` as a common mistake. `screen` keeps query access consistent and readable across tests.",
              "tags": [
                "rtl-queries",
                "rtl-utilities",
                "common-mistakes"
              ]
            },
            {
              "id": "TF-7",
              "question": "RTL's `render` function works without a DOM environment — it creates a virtual representation that does not require jsdom or a real browser.",
              "answer": false,
              "explanation": "`render` creates real DOM elements using DOM APIs like `document.createElement`. It requires a DOM environment like jsdom to function. Without a DOM environment, these APIs are unavailable and `render` will fail.",
              "tags": [
                "rtl-utilities"
              ]
            },
            {
              "id": "TF-8",
              "question": "RTL's `cleanup` function unmounts the rendered component and removes it from the DOM. In Vitest with RTL, cleanup runs automatically after each test.",
              "answer": true,
              "explanation": "`cleanup` unmounts components and clears the DOM. RTL with Vitest auto-cleans after each test via a setup hook.",
              "tags": [
                "rtl-utilities",
                "foundations"
              ]
            },
            {
              "id": "TF-9",
              "question": "You need to manually call `cleanup()` in an `afterEach` block in every test file when using Vitest with RTL.",
              "answer": false,
              "explanation": "False. RTL automatically calls `cleanup` after each test when it detects a supported framework. With Vitest, this works out of the box with no manual cleanup required. (`setupFiles` are typically used for other global setup like importing `@testing-library/jest-dom` matchers, not for cleanup.)",
              "tags": [
                "rtl-utilities",
                "jest-dom"
              ]
            },
            {
              "id": "TF-10",
              "question": "`getByTestId` is the highest-priority query in RTL's recommended query hierarchy because it provides the most stable selectors.",
              "answer": false,
              "explanation": "`getByRole` is the highest-priority query because it queries elements the way assistive technology sees them. `getByTestId` is actually the LOWEST priority — it should be a last resort when no accessible query works. The hierarchy prioritizes queries that reflect how real users interact with the page.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles",
                "foundations"
              ]
            },
            {
              "id": "TF-11",
              "question": "`getByTestId` is the preferred query method because it is the most stable and never breaks.",
              "answer": false,
              "explanation": "`getByTestId` is the lowest-priority query. It tests nothing about accessibility and should only be used as a last resort.",
              "tags": [
                "rtl-queries",
                "accessible-queries"
              ]
            },
            {
              "id": "TF-12",
              "question": "The recommended query priority places `getByTestId` above `getByRole` because test IDs are more stable than ARIA roles.",
              "answer": false,
              "explanation": "The recommended priority is the opposite: `getByRole` > `getByLabelText` > `getByText` > `getByTestId`. Role-based queries reflect how assistive technology and users interact with the page. Test IDs are the lowest priority because they are invisible to users and create test-to-DOM coupling.",
              "tags": [
                "rtl-queries",
                "accessible-queries"
              ]
            },
            {
              "id": "TF-13",
              "question": "`getByRole('button', { name: /submit/i })` finds a button by matching against its CSS class name.",
              "answer": false,
              "explanation": "The `name` option in `getByRole` matches against the element's ACCESSIBLE NAME, not its CSS class. Accessible name comes from text content, `aria-label`, `aria-labelledby`, or associated `<label>` elements. CSS classes are not part of the accessible interface.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles"
              ]
            },
            {
              "id": "TF-14",
              "question": "The `name` option in `getByRole` matches against the element's `id` attribute.",
              "answer": false,
              "explanation": "The `name` option matches against the element's ACCESSIBLE NAME, not its `id` attribute. Accessible name can come from text content, `aria-label`, `aria-labelledby`, or an associated `<label>`. The `id` attribute is not a source of accessible name (though it can be referenced by `aria-labelledby`).",
              "tags": [
                "rtl-queries",
                "accessible-queries"
              ]
            },
            {
              "id": "TF-15",
              "question": "HTML `<button>` elements require an explicit `role=\"button\"` attribute to be queryable with `getByRole('button')`.",
              "answer": false,
              "explanation": "`<button>` has an IMPLICIT ARIA role of `\"button\"` per the HTML specification. No explicit `role` attribute is needed. Many HTML elements have implicit roles: `<a href>` is `link`, `<input type=\"checkbox\">` is `checkbox`, `<nav>` is `navigation`, etc.",
              "tags": [
                "accessible-queries",
                "aria-roles",
                "foundations"
              ]
            },
            {
              "id": "TF-16",
              "question": "An `<input type=\"text\">` has an implicit ARIA role of `\"textbox\"`.",
              "answer": true,
              "explanation": "`<input type=\"text\">` maps to the ARIA role `textbox`.",
              "tags": [
                "accessible-queries",
                "aria-roles",
                "foundations"
              ]
            },
            {
              "id": "TF-17",
              "question": "An `<a href=\"...\">` element has an implicit ARIA role of `\"link\"`.",
              "answer": true,
              "explanation": "`<a href=\"...\">` has the implicit role `link`. (Note: `<a>` without `href` has no implicit role.)",
              "tags": [
                "accessible-queries",
                "aria-roles",
                "foundations"
              ]
            },
            {
              "id": "TF-18",
              "question": "An `<h1>` element has an implicit ARIA role of `\"heading\"` with `level: 1`.",
              "answer": true,
              "explanation": "`<h1>` has role `heading` with `aria-level` of `1`. You can query it with `getByRole('heading', { level: 1 })`.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles",
                "foundations"
              ]
            },
            {
              "id": "TF-19",
              "question": "You can query a specific heading level with `getByRole('heading', { level: 2 })` to find an `<h2>`.",
              "answer": true,
              "explanation": "The `level` option in `getByRole('heading', { level: 2 })` matches heading elements of that specific level.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles"
              ]
            },
            {
              "id": "TF-20",
              "question": "A `<select>` element without a `multiple` attribute and without a `size` attribute greater than 1 has an implicit ARIA role of `\"combobox\"`.",
              "answer": true,
              "explanation": "True. Per the HTML Accessibility API Mappings spec, a single-select `<select>` (no `multiple`, no `size > 1`) maps to the `combobox` role. A `<select>` with `multiple` or `size > 1` maps to `listbox` instead.",
              "tags": [
                "accessible-queries",
                "aria-roles"
              ]
            },
            {
              "id": "TF-21",
              "question": "An `<input type=\"checkbox\">` has an implicit ARIA role of `\"checkbox\"`.",
              "answer": true,
              "explanation": "`<input type=\"checkbox\">` has the implicit ARIA role `checkbox`.",
              "tags": [
                "accessible-queries",
                "aria-roles",
                "foundations"
              ]
            },
            {
              "id": "TF-22",
              "question": "`getByLabelText` is the preferred query for form fields because it mimics how users identify form controls — by their labels.",
              "answer": true,
              "explanation": "`getByLabelText` mimics how sighted users (via label text) and assistive technology users (via label association) identify form controls.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "foundations"
              ]
            },
            {
              "id": "TF-23",
              "question": "`getByLabelText(\"Email\")` finds an input that has an associated `<label>` with the text \"Email\", either via `htmlFor`/`id` pairing or by wrapping.",
              "answer": true,
              "explanation": "`getByLabelText` follows the label-input association, whether via `htmlFor`/`id`, wrapping `<label>`, or `aria-labelledby`.",
              "tags": [
                "rtl-queries",
                "accessible-queries"
              ]
            },
            {
              "id": "TF-24",
              "question": "`getByText` finds elements by their visible text content and is the best choice for non-interactive content like paragraphs and headings.",
              "answer": true,
              "explanation": "`getByText` is good for non-interactive elements where the visible text is the most natural identifier. For interactive elements, `getByRole` is preferred.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles"
              ]
            },
            {
              "id": "TF-25",
              "question": "`getByPlaceholderText` is a higher-priority query than `getByLabelText` because placeholder text is always visible.",
              "answer": false,
              "explanation": "`getByPlaceholderText` is lower priority than `getByLabelText`. Labels are more accessible than placeholders, which disappear when the user starts typing.",
              "tags": [
                "rtl-queries",
                "accessible-queries"
              ]
            },
            {
              "id": "TF-26",
              "question": "`getByDisplayValue` finds form elements by their current value and is useful for finding inputs that already have a value filled in.",
              "answer": true,
              "explanation": "`getByDisplayValue` is useful for finding pre-filled form fields by their current value.",
              "tags": [
                "rtl-queries",
                "accessible-queries"
              ]
            },
            {
              "id": "TF-27",
              "question": "`getByAltText` is used to find elements (typically images) by their `alt` attribute text.",
              "answer": true,
              "explanation": "`getByAltText` targets the `alt` attribute, primarily used for images.",
              "tags": [
                "rtl-queries",
                "accessible-queries"
              ]
            },
            {
              "id": "TF-28",
              "question": "`getByTitle` queries elements by their `title` attribute and is a higher-priority query than `getByRole`.",
              "answer": false,
              "explanation": "`getByTitle` is a lower-priority semantic query. `getByRole` is always the highest priority.",
              "tags": [
                "rtl-queries",
                "accessible-queries"
              ]
            },
            {
              "id": "TF-29",
              "question": "`getByTestId` queries elements by their `data-testid` attribute and should be used as a last resort when no semantic query works.",
              "answer": true,
              "explanation": "`getByTestId` is the last resort. It has no semantic meaning and is invisible to users.",
              "tags": [
                "rtl-queries",
                "accessible-queries"
              ]
            },
            {
              "id": "TF-30",
              "question": "`getBy` queries throw an error if no matching element is found.",
              "answer": true,
              "explanation": "`getBy` throws immediately if no match is found, which causes the test to fail with a descriptive error.",
              "tags": [
                "rtl-queries",
                "foundations"
              ]
            },
            {
              "id": "TF-31",
              "question": "`getBy` queries throw an error if more than one matching element is found.",
              "answer": true,
              "explanation": "`getBy` also throws if multiple matches are found. It expects exactly one matching element.",
              "tags": [
                "rtl-queries"
              ]
            },
            {
              "id": "TF-32",
              "question": "`queryBy` returns `null` if no matching element is found, rather than throwing.",
              "answer": true,
              "explanation": "`queryBy` returns `null` on no match instead of throwing, making it safe for negative assertions.",
              "tags": [
                "rtl-queries",
                "foundations"
              ]
            },
            {
              "id": "TF-33",
              "question": "`getBy` is the correct choice when you want to assert that an element does NOT exist in the DOM.",
              "answer": false,
              "explanation": "`queryBy` is the correct choice for asserting absence. `getBy` throws an error when the element is not found, which would fail the test before the assertion runs. The correct pattern is `expect(screen.queryByText(\"X\")).not.toBeInTheDocument()`.",
              "tags": [
                "rtl-queries",
                "jest-dom"
              ]
            },
            {
              "id": "TF-34",
              "question": "`findBy` queries are synchronous — they return the element immediately or throw if not found, just like `getBy`.",
              "answer": false,
              "explanation": "`findBy` queries return a Promise that resolves when the element appears in the DOM. They are designed for elements that appear asynchronously (e.g., after data fetching). `getBy` is the synchronous variant that throws immediately if the element is not found.",
              "tags": [
                "rtl-queries",
                "async-testing",
                "rtl-utilities",
                "foundations"
              ]
            },
            {
              "id": "TF-35",
              "question": "`findBy` and `waitFor` are completely unrelated utilities with different underlying mechanisms.",
              "answer": false,
              "explanation": "`findBy` is actually syntactic sugar for `waitFor(() => getBy(...))`. They use the same underlying mechanism — `findBy` is just a more convenient and readable API for the common case of waiting for a single element to appear.",
              "tags": [
                "rtl-queries",
                "async-testing"
              ]
            },
            {
              "id": "TF-36",
              "question": "`getAllBy` returns an array of all matching elements and throws if no elements are found.",
              "answer": true,
              "explanation": "`getAllBy` returns an array of matching elements and throws if the array would be empty.",
              "tags": [
                "rtl-queries",
                "foundations"
              ]
            },
            {
              "id": "TF-37",
              "question": "`queryAllBy` returns an empty array if no matching elements are found, rather than throwing.",
              "answer": true,
              "explanation": "`queryAllBy` returns an empty array `[]` when no matches are found, rather than throwing.",
              "tags": [
                "rtl-queries"
              ]
            },
            {
              "id": "TF-38",
              "question": "If you want to assert that exactly 3 items are rendered in a list, you should use `getAllByRole('listitem')` and assert on the array length.",
              "answer": true,
              "explanation": "`getAllByRole('listitem')` returns all matching elements, and you can assert `expect(items).toHaveLength(3)`.",
              "tags": [
                "rtl-queries",
                "aria-roles",
                "rtl-utilities"
              ]
            },
            {
              "id": "TF-39",
              "question": "`user-event` and `fireEvent` are identical in behavior — they fire the exact same events in the same order.",
              "answer": false,
              "explanation": "`user-event` simulates user interactions much more realistically than `fireEvent`. `fireEvent.click` fires only the `click` event, while `user.click` fires the full sequence: `pointerdown`, `mousedown`, `pointerup`, `mouseup`, `click`, and potentially `focus`. This makes `user-event` better at catching real bugs.",
              "tags": [
                "user-event",
                "common-mistakes",
                "foundations"
              ]
            },
            {
              "id": "TF-40",
              "question": "`fireEvent.click(element)` fires the full sequence of pointer, mouse, focus, and click events, just like a real browser click.",
              "answer": false,
              "explanation": "`fireEvent.click` fires ONLY the synthetic `click` event. It does NOT fire the full sequence. `user.click` from `user-event` is what fires the realistic sequence: `pointerdown`, `mousedown`, `pointerup`, `mouseup`, `click`, and potentially `focus`.",
              "tags": [
                "user-event",
                "common-mistakes"
              ]
            },
            {
              "id": "TF-41",
              "question": "`user-event` is always preferred over `fireEvent` because it better simulates actual user behavior.",
              "answer": false,
              "explanation": "False. `user-event` is preferred for simulating user interactions (clicks, typing, tabbing), but `fireEvent` remains appropriate for non-user events like `resize`, `scroll`, or custom DOM events, and for cases where you need to dispatch a specific synthetic event. For the vast majority of component tests, `user-event` is the right choice.",
              "tags": [
                "user-event",
                "common-mistakes",
                "foundations"
              ]
            },
            {
              "id": "TF-42",
              "question": "The recommended setup for `user-event` in a test is `const user = userEvent.setup()`, which returns a user instance for the test.",
              "answer": true,
              "explanation": "`userEvent.setup()` creates a configured user instance. This pattern is recommended over calling `userEvent.click()` directly.",
              "tags": [
                "user-event",
                "foundations"
              ]
            },
            {
              "id": "TF-43",
              "question": "`user.type(element, \"hello\")` simulates a user typing \"hello\" character by character, firing all keyboard events for each character.",
              "answer": true,
              "explanation": "`user.type` simulates character-by-character input, including `keydown`, `keypress`, `input`, and `keyup` for each character.",
              "tags": [
                "user-event"
              ]
            },
            {
              "id": "TF-44",
              "question": "`user.clear(element)` clears the current value of a text input by selecting all text and deleting it.",
              "answer": true,
              "explanation": "`user.clear` selects all text in the input and deletes it, simulating Ctrl+A followed by Delete.",
              "tags": [
                "user-event"
              ]
            },
            {
              "id": "TF-45",
              "question": "`user.click(element)` is synchronous and does not need to be awaited.",
              "answer": false,
              "explanation": "All `user-event` methods are async and return Promises. You must `await` them.",
              "tags": [
                "user-event",
                "async-testing"
              ]
            },
            {
              "id": "TF-46",
              "question": "All `user-event` methods return Promises and should be awaited.",
              "answer": true,
              "explanation": "Every `user-event` interaction method returns a Promise. Always `await` them to ensure all events have been processed.",
              "tags": [
                "user-event",
                "async-testing",
                "foundations"
              ]
            },
            {
              "id": "TF-47",
              "question": "`user.selectOptions(selectElement, ['option1'])` simulates selecting an option from a `<select>` dropdown.",
              "answer": true,
              "explanation": "`user.selectOptions` simulates selecting one or more options from a `<select>` or listbox element.",
              "tags": [
                "aria-roles",
                "user-event"
              ]
            },
            {
              "id": "TF-48",
              "question": "`user.tab()` simulates pressing the Tab key, moving focus to the next focusable element.",
              "answer": true,
              "explanation": "`user.tab()` moves focus to the next focusable element, simulating the Tab key press.",
              "tags": [
                "user-event"
              ]
            },
            {
              "id": "TF-49",
              "question": "`user.keyboard('{Enter}')` simulates pressing the Enter key.",
              "answer": true,
              "explanation": "Special keys are specified with curly braces: `{Enter}`, `{Escape}`, `{Tab}`, `{Backspace}`, etc.",
              "tags": [
                "user-event"
              ]
            },
            {
              "id": "TF-50",
              "question": "`waitFor` repeatedly calls the provided callback until it stops throwing or the timeout is reached.",
              "answer": true,
              "explanation": "`waitFor` polls the callback at intervals until it succeeds (no throw) or the timeout expires, at which point it throws the last error.",
              "tags": [
                "async-testing",
                "foundations"
              ]
            },
            {
              "id": "TF-51",
              "question": "`waitFor` is the only way to test async behavior in RTL.",
              "answer": false,
              "explanation": "`findBy` queries also handle async elements. `waitFor` is for more complex async scenarios; `findBy` is preferred for simply waiting for an element to appear.",
              "tags": [
                "rtl-queries",
                "async-testing"
              ]
            },
            {
              "id": "TF-52",
              "question": "`waitForElementToBeRemoved` waits until the queried element is no longer in the DOM, useful for testing loading states that disappear.",
              "answer": true,
              "explanation": "`waitForElementToBeRemoved` waits for the element to be removed from the DOM. It is useful for verifying that loading indicators disappear.",
              "tags": [
                "async-testing"
              ]
            },
            {
              "id": "TF-53",
              "question": "The `waitFor` + `getBy` combination is preferred over `findBy` for waiting for an element to appear.",
              "answer": false,
              "explanation": "`findBy` is preferred over `waitFor` + `getBy` for the common case of waiting for an element to appear. It is cleaner and more readable. Kent C. Dodds specifically recommends `findBy` over the `waitFor` + `getBy` combination.",
              "tags": [
                "rtl-queries",
                "async-testing",
                "common-mistakes"
              ]
            },
            {
              "id": "TF-54",
              "question": "Wrapping `render()` calls inside `act()` manually is necessary in RTL tests to avoid state update warnings.",
              "answer": false,
              "explanation": "RTL already wraps `render` and `fireEvent` in `act()`. Manually adding `act()` is unnecessary and is listed as a common mistake by KCD.",
              "tags": [
                "user-event",
                "rtl-utilities",
                "common-mistakes"
              ]
            },
            {
              "id": "TF-55",
              "question": "RTL's `render` and `user-event` methods already handle `act()` internally, so you should not manually wrap calls in `act()` in most cases.",
              "answer": true,
              "explanation": "RTL handles `act()` internally. Adding it manually creates noise and indicates a misunderstanding of the library.",
              "tags": [
                "user-event",
                "rtl-utilities",
                "common-mistakes",
                "foundations"
              ]
            },
            {
              "id": "TF-56",
              "question": "`screen.debug()` prints the current DOM tree to the console, which is useful for debugging test failures.",
              "answer": true,
              "explanation": "`screen.debug()` pretty-prints the current DOM to the console, helping you see what the test \"sees.\"",
              "tags": [
                "rtl-queries",
                "rtl-utilities",
                "foundations"
              ]
            },
            {
              "id": "TF-57",
              "question": "`screen.debug()` takes an optional element argument: `screen.debug(element)` prints only that element's subtree.",
              "answer": true,
              "explanation": "`screen.debug(element)` narrows the output to just the subtree of the specified element.",
              "tags": [
                "rtl-queries",
                "rtl-utilities"
              ]
            },
            {
              "id": "TF-58",
              "question": "`logRoles` is an RTL utility that prints all the ARIA roles found in the rendered DOM, helping you discover which roles to use in `getByRole`.",
              "answer": true,
              "explanation": "`logRoles` lists all ARIA roles in the container, which helps you write correct `getByRole` queries.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles",
                "rtl-utilities"
              ]
            },
            {
              "id": "TF-59",
              "question": "The `within` function from RTL lets you scope queries to a specific container element, creating a \"mini screen\" for a subtree.",
              "answer": true,
              "explanation": "`within` scopes all queries to a specific container, useful when the same text or role appears in multiple parts of the page.",
              "tags": [
                "rtl-queries",
                "rtl-utilities",
                "foundations"
              ]
            },
            {
              "id": "TF-60",
              "question": "`within(container).getByText(\"hello\")` searches for \"hello\" only inside `container`, not the entire document.",
              "answer": true,
              "explanation": "`within(container)` returns a bound set of query methods that only search inside `container`.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "rtl-utilities"
              ]
            },
            {
              "id": "TF-61",
              "question": "The `render` function's `wrapper` option lets you specify a component that wraps the rendered component, useful for providing Context, ThemeProvider, or other required providers.",
              "answer": true,
              "explanation": "The `wrapper` option in `render` wraps the component in a provider. This avoids repeating provider boilerplate in every test.",
              "tags": [
                "rtl-utilities",
                "foundations"
              ]
            },
            {
              "id": "TF-62",
              "question": "RTL tests should always test components in complete isolation, never with their child components.",
              "answer": false,
              "explanation": "RTL encourages rendering components with their real children when practical. Full isolation (mocking all children) tests implementation details rather than behavior.",
              "tags": [
                "rtl-philosophy",
                "rtl-utilities"
              ]
            },
            {
              "id": "TF-63",
              "question": "RTL best practice is to mock all child components when testing a parent, so each component is tested in complete isolation.",
              "answer": false,
              "explanation": "RTL encourages testing components as users experience them, which often means rendering with REAL children rather than mocking everything. Excessive mocking reduces confidence because it tests something different from what users actually encounter.",
              "tags": [
                "rtl-philosophy",
                "rtl-utilities"
              ]
            },
            {
              "id": "TF-64",
              "question": "`getByRole('textbox')` can find both `<input type=\"text\">` and `<textarea>` elements because both have the `textbox` role.",
              "answer": true,
              "explanation": "Both `<input type=\"text\">` and `<textarea>` have the `textbox` role, so `getByRole('textbox')` can match either.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles"
              ]
            },
            {
              "id": "TF-65",
              "question": "Regex matchers passed to query methods (e.g., `getByText(/submit/i)`) are useful for case-insensitive matching and partial text matching.",
              "answer": true,
              "explanation": "Regex matchers are useful for flexible matching. `/submit/i` matches \"Submit\", \"SUBMIT\", \"submit\", or any element containing \"submit\" as a substring.",
              "tags": [
                "rtl-queries",
                "accessible-queries"
              ]
            },
            {
              "id": "TF-66",
              "question": "`getByText(\"Submit\")` performs an exact string match by default and will not match \"Submit Form\".",
              "answer": true,
              "explanation": "By default, `getByText(\"Submit\")` is an exact, full-content match. \"Submit Form\" would not match.",
              "tags": [
                "rtl-queries",
                "accessible-queries"
              ]
            },
            {
              "id": "TF-67",
              "question": "You can pass `{ exact: false }` as an option to `getByText` to enable substring matching.",
              "answer": true,
              "explanation": "`{ exact: false }` enables substring matching for text queries.",
              "tags": [
                "rtl-queries",
                "accessible-queries"
              ]
            },
            {
              "id": "TF-68",
              "question": "`getByRole('button', { name: \"Submit\" })` performs an exact string match on the accessible name by default.",
              "answer": true,
              "explanation": "The `name` option in `getByRole` performs an exact string match by default. Use regex for flexible matching.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles"
              ]
            },
            {
              "id": "TF-69",
              "question": "`screen.getByRole('dialog')` can find elements with `role=\"dialog\"` or native `<dialog>` elements.",
              "answer": true,
              "explanation": "Both explicit `role=\"dialog\"` and native `<dialog>` elements have the `dialog` role and can be found with `getByRole('dialog')`.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles"
              ]
            },
            {
              "id": "TF-70",
              "question": "`data-testid` attributes are visible to users and assistive technology, making them a good choice for accessibility.",
              "answer": false,
              "explanation": "`data-testid` attributes are invisible to users and meaningless to assistive technology. They are a testing-only concern that creates coupling between tests and the DOM. They should be minimized and used only when no accessible query is available.",
              "tags": [
                "general"
              ]
            },
            {
              "id": "TF-71",
              "question": "`user.type(input, \"abc{backspace}\")` types \"abc\" and then simulates pressing Backspace, resulting in \"ab\" in the input.",
              "answer": true,
              "explanation": "`user.type` interprets `{backspace}` as a special key. After typing \"abc\", Backspace deletes \"c\", leaving \"ab\".",
              "tags": [
                "user-event"
              ]
            },
            {
              "id": "TF-72",
              "question": "`findByRole` and other `findBy` queries accept a `timeout` option that controls how long to wait before giving up.",
              "answer": true,
              "explanation": "`findBy` queries accept options including `timeout` (default 1000ms) and `interval` to customize waiting behavior.",
              "tags": [
                "rtl-queries",
                "async-testing"
              ]
            }
          ]
        },
        {
          "type": "short_answer",
          "count": 16,
          "questions": [
            {
              "id": "SA-1",
              "question": "List the RTL query priority hierarchy from highest to lowest priority. For each level, give one example query and explain why it has that priority.",
              "model_answer": "The RTL query priority hierarchy, highest to lowest:\n\n1. **Queries Accessible to Everyone:** `getByRole` (highest — queries by ARIA role, the way assistive technology sees elements; e.g., `getByRole('button')`), `getByLabelText` (finds form controls by their label text; e.g., `getByLabelText('Email')`), `getByPlaceholderText`, `getByText` (finds by visible text content; e.g., `getByText('Submit')`), `getByDisplayValue`.\n\n2. **Semantic Queries:** `getByAltText` (finds images by `alt` text; e.g., `getByAltText('Logo')`), `getByTitle`.\n\n3. **Test IDs:** `getByTestId` (lowest — queries by `data-testid` attribute, invisible to users; e.g., `getByTestId('submit-btn')`). Used only as a last resort.\n\nHigher-priority queries are preferred because they reflect how real users (including those using assistive technology) find elements. Lower-priority queries are fallbacks for when no semantic query works.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles",
                "foundations"
              ]
            },
            {
              "id": "SA-2",
              "question": "Explain the difference between `getBy`, `queryBy`, and `findBy`. When would you use each one?",
              "model_answer": "`getBy` returns the matching element immediately or throws if none (or more than one) is found. Use it when the element should already be in the DOM.\n\n`queryBy` returns the element if found, or `null` if not. It never throws on no match. Use it when asserting that an element does NOT exist: `expect(screen.queryByText(\"Error\")).not.toBeInTheDocument()`.\n\n`findBy` returns a Promise that resolves when the element appears in the DOM (it retries on an interval). Use it when the element will appear asynchronously, such as after a data fetch or state update: `const message = await screen.findByText(\"Success\")`.",
              "tags": [
                "rtl-queries",
                "async-testing",
                "jest-dom",
                "foundations"
              ]
            },
            {
              "id": "SA-3",
              "question": "What is the accessible name of the following button, and how would you query it with `getByRole`?\n\n```tsx\n<button aria-label=\"Close dialog\">X</button>\n```",
              "model_answer": "The accessible name is `\"Close dialog\"`, because `aria-label` overrides the text content \"X\" for the accessible name. Query it with:\n\n```ts\nscreen.getByRole('button', { name: /close dialog/i })\n```",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles"
              ]
            },
            {
              "id": "SA-4",
              "question": "Write a test that renders a `LoginForm` component, finds the email input by its label, the password input by its label, and the submit button by its role, types credentials, clicks submit, and asserts that a success message appears. Use `user-event` and accessible queries.",
              "model_answer": "```tsx\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginForm from './LoginForm';\n\nit(\"submits credentials and shows success\", async () => {\n  const user = userEvent.setup();\n  render(<LoginForm />);\n\n  const emailInput = screen.getByLabelText(/email/i);\n  const passwordInput = screen.getByLabelText(/password/i);\n  const submitButton = screen.getByRole('button', { name: /submit/i });\n\n  await user.type(emailInput, \"alice@example.com\");\n  await user.type(passwordInput, \"password123\");\n  await user.click(submitButton);\n\n  expect(await screen.findByText(/success/i)).toBeInTheDocument();\n});\n```\n\nThe test uses `getByLabelText` for form fields (accessible, label-based), `getByRole` for the button (highest-priority query), `user-event` for realistic interaction, and `findByText` for the async success message.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles",
                "user-event",
                "async-testing",
                "rtl-utilities",
                "jest-dom"
              ]
            },
            {
              "id": "SA-5",
              "question": "Explain why `user-event` is preferred over `fireEvent`. Give a specific example where the difference matters.",
              "model_answer": "`user-event` is preferred because it simulates the full sequence of events that a real browser fires. `fireEvent.click(button)` dispatches only a synthetic `click` event. `user.click(button)` fires `pointerdown`, `mousedown`, `pointerup`, `mouseup`, `click`, and also handles focus changes.\n\nThis matters for components that listen to events other than `click`. For example, a dropdown that opens on `mousedown` (not `click`) would work correctly with `user.click` but not with `fireEvent.click`. Similarly, `user.type` fires all keyboard events character by character, which matters for components with `onKeyDown` handlers or input masking.",
              "tags": [
                "aria-roles",
                "user-event",
                "common-mistakes",
                "foundations"
              ]
            },
            {
              "id": "SA-6",
              "question": "What does `screen.debug()` do? When would you use it, and what additional debugging tool does RTL provide for discovering ARIA roles?",
              "model_answer": "`screen.debug()` pretty-prints the current state of the DOM tree to the console. Use it when a test fails and you want to see what the test \"sees\" — which elements are present, what their text content is, and what the DOM structure looks like.\n\nFor discovering ARIA roles, use `logRoles(container)` from `@testing-library/dom`. It prints all elements with their computed ARIA roles, which helps you determine the correct role to pass to `getByRole`. For example, you might discover that your custom component renders with role `textbox` instead of `input`.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles",
                "rtl-utilities"
              ]
            },
            {
              "id": "SA-7",
              "question": "Explain the `within` utility. Write a short test snippet that uses `within` to find a button inside a specific section of the page.",
              "model_answer": "`within` scopes all queries to a specific container element, useful when the same text or role appears in multiple parts of the page:\n\n```tsx\nimport { render, screen, within } from '@testing-library/react';\n\nit(\"finds the save button inside the header\", () => {\n  render(<Page />);\n\n  const header = screen.getByRole('banner');\n  const saveButton = within(header).getByRole('button', { name: /save/i });\n\n  expect(saveButton).toBeInTheDocument();\n});\n```\n\nWithout `within`, `getByRole('button', { name: /save/i })` might match a save button in the footer instead. `within` narrows the search to just the header.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles",
                "rtl-utilities",
                "jest-dom"
              ]
            },
            {
              "id": "SA-8",
              "question": "Why does KCD say not to wrap things in `act()` when using RTL? What does RTL do behind the scenes that makes manual `act()` unnecessary?",
              "model_answer": "KCD says manual `act()` wrapping is unnecessary because RTL already wraps `render`, `fireEvent`, and `user-event` calls in `act()` behind the scenes. React's `act()` ensures that all state updates and effects triggered by an interaction are flushed before the test proceeds. Since RTL handles this for you, adding `act()` manually creates noise, makes tests harder to read, and can mask real async issues (where you should be using `findBy` or `waitFor` instead of forcing synchronous flushing).",
              "tags": [
                "rtl-queries",
                "user-event",
                "async-testing",
                "rtl-utilities",
                "common-mistakes"
              ]
            },
            {
              "id": "SA-9",
              "question": "Write a test that asserts an element does NOT exist in the DOM. Explain why you must use `queryBy` instead of `getBy` for this assertion.",
              "model_answer": "```tsx\nit(\"does not show an error message initially\", () => {\n  render(<Form />);\n\n  expect(screen.queryByText(\"Invalid email\")).not.toBeInTheDocument();\n});\n```\n\nYou must use `queryByText` because `getByText` throws if the element is not found. Since we are asserting the element does NOT exist, throwing would crash the test before the assertion runs. `queryByText` returns `null` when the element is absent, which allows `.not.toBeInTheDocument()` to pass.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "rtl-utilities",
                "jest-dom"
              ]
            },
            {
              "id": "SA-10",
              "question": "Explain the `render` function's `wrapper` option. Write a test that renders a component with a ThemeProvider wrapper.",
              "model_answer": "The `wrapper` option in `render` wraps the component being tested in a specified provider component. This is useful when the component requires Context (theme, router, state) to render:\n\n```tsx\nimport { ThemeProvider, createTheme } from '@mui/material';\n\nconst theme = createTheme();\n\nit(\"renders with theme\", () => {\n  render(<MyComponent />, {\n    wrapper: ({ children }) => (\n      <ThemeProvider theme={theme}>{children}</ThemeProvider>\n    ),\n  });\n\n  expect(screen.getByText(\"Themed content\")).toBeInTheDocument();\n});\n```\n\nThis avoids wrapping the component manually inside `render(<ThemeProvider><MyComponent /></ThemeProvider>)` and is especially powerful when combined with a custom `renderWithProviders` utility used across all tests.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "rtl-utilities",
                "jest-dom"
              ]
            },
            {
              "id": "SA-11",
              "question": "What is the implicit ARIA role for each of these HTML elements: `<button>`, `<a href=\"...\">`, `<input type=\"text\">`, `<input type=\"checkbox\">`, `<h2>`, `<ul>`, `<li>`, `<img alt=\"photo\">`?",
              "model_answer": "- `<button>` → `button`\n- `<a href=\"...\">` → `link`\n- `<input type=\"text\">` → `textbox`\n- `<input type=\"checkbox\">` → `checkbox`\n- `<h2>` → `heading` (level 2)\n- `<ul>` → `list`\n- `<li>` → `listitem`\n- `<img alt=\"photo\">` → `img`",
              "tags": [
                "accessible-queries",
                "aria-roles",
                "foundations"
              ]
            },
            {
              "id": "SA-12",
              "question": "Explain the difference between `findBy` and `waitFor` + `getBy`. When should you use each pattern?",
              "model_answer": "`findBy` is shorthand for `waitFor(() => getBy(...))`. Use `findBy` when you are simply waiting for a single element to appear in the DOM — it is cleaner and more readable.\n\nUse `waitFor` explicitly when you need to wait for a condition that is not just an element appearing — for example, waiting for an element's text to change, waiting for a specific number of elements to appear, or waiting for a complex async side effect. `waitFor` gives you full control over the assertion inside the callback, whereas `findBy` is specifically for element appearance.",
              "tags": [
                "rtl-queries",
                "async-testing"
              ]
            },
            {
              "id": "SA-13",
              "question": "KCD's article \"Common Mistakes with React Testing Library\" lists several mistakes. Name three specific mistakes and explain the correct approach for each.",
              "model_answer": "Three common mistakes from KCD's article:\n\n1. **Using `getByTestId` as the default query.** Correct: Use `getByRole` first, then `getByLabelText`, then `getByText`. `getByTestId` is a last resort.\n\n2. **Wrapping things in `act()` unnecessarily.** Correct: RTL's `render` and `user-event` already handle `act()`. If you see `act()` warnings, the fix is usually to `await` async operations or use `findBy` queries, not to add more `act()` wrappers.\n\n3. **Using `fireEvent` instead of `user-event`.** Correct: `user-event` simulates real user interactions more accurately. Always prefer `user.click()` over `fireEvent.click()`.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "user-event",
                "async-testing",
                "rtl-utilities",
                "common-mistakes"
              ]
            },
            {
              "id": "SA-14",
              "question": "What does `getAllByRole('listitem')` return when there are 5 `<li>` elements inside a `<ul>`? How do you assert on the count?",
              "model_answer": "`getAllByRole('listitem')` returns an array of 5 DOM elements (one for each `<li>`). To assert the count:\n\n```ts\nconst items = screen.getAllByRole('listitem');\nexpect(items).toHaveLength(5);\n```\n\nIf you needed to check a specific item's content, you could index into the array: `expect(items[0]).toHaveTextContent(\"First item\")`.",
              "tags": [
                "rtl-queries",
                "aria-roles",
                "jest-dom"
              ]
            },
            {
              "id": "SA-15",
              "question": "A developer writes this test but it fails. Explain why and fix it.\n\n```tsx\nit(\"shows error on invalid email\", () => {\n  render(<LoginForm />);\n  const input = screen.getByTestId(\"email-input\");\n  fireEvent.change(input, { target: { value: \"invalid\" } });\n  fireEvent.click(screen.getByTestId(\"submit-btn\"));\n  expect(screen.getByTestId(\"error-msg\")).toBeInTheDocument();\n});\n```",
              "model_answer": "The test has several issues related to query and event choices:\n\n1. **Query choice:** All three queries use `getByTestId`, which is the lowest-priority query. The email input should use `getByLabelText(/email/i)` or `getByRole('textbox', { name: /email/i })`. The submit button should use `getByRole('button', { name: /submit/i })`. The error message should use `getByText` or `getByRole('alert')`.\n\n2. **Event simulation:** `fireEvent.change` dispatches a synthetic change event. `user.type` is preferred because it simulates real keystroke-by-keystroke typing, which may be needed for validation logic that runs on each keystroke. Similarly, `user.click` should replace `fireEvent.click`.\n\nImproved version:\n```tsx\nit(\"shows error on invalid email\", async () => {\n  const user = userEvent.setup();\n  render(<LoginForm />);\n\n  await user.type(screen.getByLabelText(/email/i), \"invalid\");\n  await user.click(screen.getByRole('button', { name: /submit/i }));\n\n  expect(screen.getByText(/invalid email/i)).toBeInTheDocument();\n});\n```",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles",
                "user-event",
                "async-testing",
                "rtl-utilities",
                "jest-dom",
                "common-mistakes"
              ]
            },
            {
              "id": "SA-16",
              "question": "What is `waitForElementToBeRemoved`? Write a test that waits for a loading spinner to disappear before asserting the final content is rendered.",
              "model_answer": "`waitForElementToBeRemoved` waits until a specified element is no longer in the DOM. It is useful for asserting that loading states complete:\n\n```tsx\nit(\"shows data after loading spinner disappears\", async () => {\n  render(<DataList />);\n\n  // Spinner should be visible initially\n  expect(screen.getByRole('progressbar')).toBeInTheDocument();\n\n  // Wait for the spinner to be removed\n  await waitForElementToBeRemoved(() => screen.queryByRole('progressbar'));\n\n  // Now the data should be visible\n  expect(screen.getByText(\"Item 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Item 2\")).toBeInTheDocument();\n});\n```\n\nNote that the callback passed to `waitForElementToBeRemoved` should use `queryBy` (not `getBy`) because the element will eventually not exist, and `getBy` would throw at that point.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "async-testing",
                "rtl-utilities",
                "jest-dom"
              ]
            },
            {
              "id": "SA-17",
              "question": "State the guiding principle of React Testing Library in your own words. Explain how this principle influences the library's API design.",
              "model_answer": "The guiding principle is: the more your tests resemble the way your software is used, the more confidence they give you. This principle drives RTL's API design in several ways: it does not expose access to component instances or internal state; its query functions find elements the way a user would (by role, label, or visible text rather than by class name or component hierarchy); and it encourages interaction through user-facing events (`user-event`) rather than programmatic state manipulation. The library intentionally lacks APIs for reading state or props because those are implementation details a user never interacts with.",
              "tags": [
                "rtl-philosophy",
                "foundations"
              ]
            },
            {
              "id": "SA-18",
              "question": "Why does RTL not provide a way to access a component's state or props directly? Explain the testing philosophy behind this design decision.",
              "model_answer": "RTL withholds access to component internals because state and props are implementation details — they describe how the component works, not what it does from the user's perspective. If tests assert on internal state, they break when the implementation changes even if the behavior is identical (false positives). By forcing tests to interact through the DOM — clicking buttons, typing in inputs, reading visible text — RTL ensures tests are coupled to behavior rather than structure. This makes tests resilient to refactors and gives genuine confidence that the application works as users expect.",
              "tags": [
                "rtl-philosophy",
                "foundations"
              ]
            },
            {
              "id": "SA-19",
              "question": "Define the three query variants `getBy`, `queryBy`, and `findBy`. For each, state what it returns when the element is found and what happens when it is NOT found.",
              "model_answer": "`getBy` returns the matching element if found; throws an error immediately if not found (or if multiple matches exist). Use it when the element should be present. `queryBy` returns the matching element if found; returns `null` if not found (does not throw). Use it to assert that an element does NOT exist: `expect(screen.queryByText('Error')).not.toBeInTheDocument()`. `findBy` returns a promise that resolves to the matching element when it appears; rejects (throws) if the element does not appear within the timeout (default 1000ms). Use it for elements that appear asynchronously after a state update, API call, or animation.",
              "tags": [
                "rtl-queries",
                "foundations"
              ]
            },
            {
              "id": "SA-20",
              "question": "Define the `All` variants of queries (`getAllBy`, `queryAllBy`, `findAllBy`). When would you use `getAllBy` instead of `getBy`?",
              "model_answer": "The `All` variants return arrays instead of single elements. `getAllBy` returns an array of all matching elements; throws if none are found. `queryAllBy` returns an array (empty array if none found — does not throw). `findAllBy` returns a promise that resolves to an array when at least one matching element appears. You use `getAllBy` instead of `getBy` when you expect multiple matching elements — for example, `screen.getAllByRole('listitem')` to get all list items. `getBy` throws if more than one element matches, so it is only appropriate when exactly one match is expected.",
              "tags": [
                "rtl-queries"
              ]
            },
            {
              "id": "SA-21",
              "question": "Reproduce the RTL query priority hierarchy from memory. For each level, name the queries and explain why they are ranked at that level.",
              "model_answer": "Priority 1 — Queries accessible to everyone: `getByRole`, `getByLabelText`, `getByPlaceholderText`, `getByText`, `getByDisplayValue`. These are highest priority because they reflect how all users (including assistive technology users) perceive the page. `getByRole` is the single most preferred query because ARIA roles map to the semantic meaning of elements.\n\nPriority 2 — Semantic queries: `getByAltText`, `getByTitle`. These rely on attributes that have specific semantic meaning but are not universally perceivable (e.g., `alt` text is primarily for images; `title` is often not exposed by assistive tech).\n\nPriority 3 — Test IDs: `getByTestId`. This is a last resort because `data-testid` is invisible to users and does not verify accessibility. It should only be used when there is no accessible way to query the element.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "foundations"
              ]
            },
            {
              "id": "SA-22",
              "question": "Define \"accessible name\" as it applies to `getByRole`. Give three ways an element can receive an accessible name.",
              "model_answer": "The accessible name is the string that assistive technologies (like screen readers) announce for an element. In `getByRole('button', { name: 'Submit' })`, the `name` option matches against this accessible name. Three ways an element gets its accessible name: (1) text content — `<button>Submit</button>` has accessible name \"Submit\"; (2) `aria-label` attribute — `<button aria-label=\"Close dialog\">X</button>` has name \"Close dialog\"; (3) associated `<label>` element — `<label for=\"email\">Email</label><input id=\"email\">` gives the input the accessible name \"Email\" (queried via `getByRole('textbox', { name: 'Email' })` or `getByLabelText('Email')`).",
              "tags": [
                "accessible-queries",
                "aria-roles",
                "foundations"
              ]
            },
            {
              "id": "SA-23",
              "question": "Define \"implicit ARIA role\" and list the implicit role for each of these HTML elements: `<button>`, `<a href=\"...\">`, `<input type=\"text\">`, `<input type=\"checkbox\">`, `<select>`, `<h1>`.",
              "model_answer": "An implicit ARIA role is the default accessibility role that a browser assigns to an HTML element based on its tag and attributes — no explicit `role` attribute is needed. The implicit roles are: `<button>` → `button`; `<a href=\"...\">` → `link` (only when `href` is present); `<input type=\"text\">` → `textbox`; `<input type=\"checkbox\">` → `checkbox`; `<select>` → `combobox`; `<h1>` → `heading` (with `level: 1`). These implicit roles are what `getByRole` matches against, which is why you can write `getByRole('button')` without adding an explicit `role=\"button\"` attribute to your HTML.",
              "tags": [
                "aria-roles",
                "accessible-queries",
                "foundations"
              ]
            },
            {
              "id": "SA-24",
              "question": "Define what `user-event` is and explain how it differs from `fireEvent` at a fundamental level. Why does the RTL documentation recommend `user-event` as the default?",
              "model_answer": "`user-event` is a companion library to Testing Library that simulates complete user interactions as they would happen in a real browser. `fireEvent` dispatches a single synthetic DOM event. The fundamental difference is fidelity: when a user clicks a button in a real browser, many events fire in sequence (pointerdown, mousedown, pointerup, mouseup, click, focus, etc.). `user-event` reproduces this full event sequence, while `fireEvent.click()` dispatches only the `click` event. Similarly, `user-event.type()` fires focus, keydown, keypress, input, and keyup for each character. RTL recommends `user-event` because it catches bugs that `fireEvent` misses — for example, a handler that listens for `mousedown` instead of `click` works in the real browser and with `user-event`, but is invisible to `fireEvent.click()`.",
              "tags": [
                "user-event",
                "foundations"
              ]
            },
            {
              "id": "SA-25",
              "question": "Explain the `userEvent.setup()` pattern. Why is it recommended over calling `userEvent.click()` directly as a static method?",
              "model_answer": "`userEvent.setup()` creates a configured user-event instance that tracks interaction state (focus, pointer position, keyboard modifiers) across multiple actions within a test. Example: `const user = userEvent.setup(); await user.click(button); await user.type(input, 'hello');`. This is preferred over static calls (`userEvent.click(button)`) because the setup instance maintains state between actions — if a click focuses an element, a subsequent `type` call knows which element has focus. Static calls do not track this state, so each interaction starts from a clean slate, which does not match real user behavior.",
              "tags": [
                "user-event",
                "foundations"
              ]
            },
            {
              "id": "SA-26",
              "question": "Explain what `user.type()` simulates that `fireEvent.change()` does not. Why does this matter for testing input validation?",
              "model_answer": "`user.type(input, 'hello')` simulates the full keystroke sequence: for each character, it fires focus (if not already focused), keydown, keypress, beforeinput, input, and keyup events. `fireEvent.change(input, { target: { value: 'hello' } })` sets the entire value at once and fires only the `change` event. This matters for input validation because many real-world forms validate on each keystroke (e.g., showing \"too short\" after typing 2 characters of a 8-character minimum password). `user.type` triggers these intermediate validations; `fireEvent.change` skips directly to the final value and misses all intermediate states.",
              "tags": [
                "user-event"
              ]
            },
            {
              "id": "SA-27",
              "question": "Name four specific user actions that `user-event` supports beyond `click` and `type`. For each, give a one-sentence description of what it simulates.",
              "model_answer": "(1) `user.clear(element)` — clears the value of an input or textarea by selecting all text and deleting it, triggering the appropriate selection and input events. (2) `user.selectOptions(select, values)` — selects one or more options in a `<select>` element, simulating the real selection interaction. (3) `user.tab()` — presses the Tab key, moving focus to the next focusable element in the DOM, useful for testing keyboard navigation and focus management. (4) `user.keyboard('{Enter}')` — simulates arbitrary keyboard input, including special keys like Enter, Escape, Arrow keys, and modifier combinations (Shift, Ctrl).",
              "tags": [
                "user-event"
              ]
            },
            {
              "id": "SA-28",
              "question": "Define `screen` as it is used in RTL. Why does KCD recommend using `screen` instead of destructuring the return value of `render`?",
              "model_answer": "`screen` is an object exported by RTL that provides all query methods (`getByRole`, `queryByText`, `findByLabelText`, etc.) bound to `document.body`. After calling `render(<MyComponent />)`, all queries on `screen` search the rendered DOM. KCD recommends `screen` over destructuring (`const { getByText } = render(...)`) for two reasons: (1) it keeps the render call and the queries visually separate, making tests easier to read; (2) you do not need to re-destructure when adding a new query type — `screen` always has all queries available. The only exception is when you need the `container` reference from `render`, which `screen` does not provide.",
              "tags": [
                "rtl-utilities",
                "foundations"
              ]
            },
            {
              "id": "SA-29",
              "question": "Define what `render` does in RTL. What does it return, and what is the `wrapper` option used for?",
              "model_answer": "`render` takes a React element, creates a DOM container, renders the element into it, and appends it to `document.body`. It returns an object containing: `container` (the DOM node wrapping the rendered output), `unmount` (a function to unmount the component), `rerender` (a function to re-render with new props), `baseElement` (usually `document.body`), and all query methods bound to the container. The `wrapper` option accepts a React component that wraps the rendered element — it is used to provide necessary context (ThemeProvider, QueryClientProvider, Router, Redux store, etc.) so the component under test has access to its required providers without each test manually wrapping JSX.",
              "tags": [
                "rtl-utilities",
                "foundations"
              ]
            },
            {
              "id": "SA-30",
              "question": "What does `cleanup` do in RTL, and why do you typically not need to call it manually with Vitest?",
              "model_answer": "`cleanup` unmounts all rendered components and removes their DOM containers from `document.body`, restoring the DOM to a clean state between tests. You typically do not need to call it manually with Vitest because RTL's Vitest integration automatically calls `cleanup` in an `afterEach` hook when properly configured (either through the setup file importing `@testing-library/react` or through auto-cleanup configuration). This ensures each test starts with a fresh DOM regardless of what the previous test rendered.",
              "tags": [
                "rtl-utilities"
              ]
            },
            {
              "id": "SA-31",
              "question": "Define `screen.debug()` and `logRoles`. When would you use each during test development?",
              "model_answer": "`screen.debug()` prints the current DOM tree to the console in a formatted, readable HTML structure. It accepts an optional element argument to print only a subtree. Use it when a query fails and you want to see what the DOM actually looks like at that point in the test. `logRoles(element)` (imported from `@testing-library/dom`) prints all ARIA roles present in the given element's subtree, listing each role with the elements that have it. Use it when you are unsure which `getByRole` query to write — it tells you exactly which roles exist and what their accessible names are. Both are debugging tools that should be removed before committing.",
              "tags": [
                "rtl-utilities"
              ]
            },
            {
              "id": "SA-32",
              "question": "Define the `within` utility. Give an example scenario where it is necessary.",
              "model_answer": "`within` takes a DOM element and returns a set of query methods scoped to that element's subtree rather than the entire document. It is necessary when the page has multiple regions with similar content and you need to query inside a specific one. Example: a page with two cards, each containing a \"Delete\" button. `screen.getByRole('button', { name: 'Delete' })` would throw because there are two matches. Instead: `const card = screen.getByRole('region', { name: 'User Settings' }); within(card).getByRole('button', { name: 'Delete' })` — this scopes the query to the specific card.",
              "tags": [
                "rtl-utilities"
              ]
            },
            {
              "id": "SA-33",
              "question": "Define what `@testing-library/jest-dom` provides. Name five custom matchers it adds and describe what each checks.",
              "model_answer": "`@testing-library/jest-dom` is a library that extends the `expect` API with DOM-specific matchers, making assertions more readable and their failure messages more descriptive. Five matchers: (1) `.toBeInTheDocument()` — checks the element is present in the document body. (2) `.toBeVisible()` — checks the element is visible (not hidden by CSS, `hidden` attribute, etc.). (3) `.toHaveTextContent(text)` — checks the element's text content matches (supports string or regex). (4) `.toBeDisabled()` — checks the element has the `disabled` attribute or is otherwise disabled. (5) `.toHaveAttribute(attr, value)` — checks the element has a specific attribute with an optional value.",
              "tags": [
                "jest-dom",
                "foundations"
              ]
            },
            {
              "id": "SA-34",
              "question": "What is the difference between `toBeInTheDocument()` and checking for a non-null return from `queryBy`? Why is `toBeInTheDocument()` preferred?",
              "model_answer": "Both can assert element presence, but they differ in semantics and error messages. `expect(screen.queryByText('Error')).not.toBeNull()` checks for non-null — its failure message says something like \"expected null not to be null,\" which is uninformative. `expect(screen.queryByText('Error')).toBeInTheDocument()` specifically asserts DOM presence — its failure message says \"expected element to be in the document\" and shows the relevant DOM context. `toBeInTheDocument()` is preferred because it makes the test's intent explicit (checking DOM presence, not just non-nullness) and produces much clearer failure messages when debugging.",
              "tags": [
                "jest-dom"
              ]
            },
            {
              "id": "SA-35",
              "question": "Define `waitFor` in RTL. Explain its polling mechanism and when you should use it versus using `findBy`.",
              "model_answer": "`waitFor` repeatedly calls a callback function at short intervals (default 50ms) until it either passes without throwing or the timeout expires (default 1000ms). It is used to wait for any asynchronous change in the DOM or state. Use `findBy` when you are waiting for a specific element to appear — `findBy` is syntactic sugar for `waitFor` + `getBy` and is more readable. Use `waitFor` directly when the assertion is more complex than \"element exists\" — for example, waiting for text content to change, for an element's attribute to update, or for multiple conditions to be true simultaneously.",
              "tags": [
                "async-testing",
                "foundations"
              ]
            },
            {
              "id": "SA-36",
              "question": "What is `waitForElementToBeRemoved`? Describe a common use case and explain what makes it different from negating a `findBy` query.",
              "model_answer": "`waitForElementToBeRemoved` waits until an element that is currently present in the DOM is removed (or becomes inaccessible to its query). A common use case is waiting for a loading indicator to disappear: `await waitForElementToBeRemoved(() => screen.getByText('Loading...'))`. It differs from negating a query because it asserts the element *starts* present and then *becomes* absent — if the element never existed, it throws immediately. This catches bugs where the loading state was never rendered at all. A negated `findBy` cannot express this \"was present, then left\" contract.",
              "tags": [
                "async-testing"
              ]
            },
            {
              "id": "SA-37",
              "question": "KCD says using `getByTestId` as a primary query is a common mistake. Explain why, and describe the circumstances where `getByTestId` is acceptable.",
              "model_answer": "`getByTestId` queries by the `data-testid` attribute, which is invisible to users and assistive technologies. Using it as a primary query means your test does not verify that the UI is accessible — if you remove the label from an input, a `getByTestId` test still passes while a `getByRole` test would catch the regression. It is acceptable only when there is genuinely no accessible way to query the element: for example, a dynamically generated container with no text, no label, no role, and no semantic meaning, where adding ARIA attributes would be incorrect. In those rare cases, `data-testid` is better than querying by class name or DOM structure.",
              "tags": [
                "common-mistakes",
                "accessible-queries",
                "foundations"
              ]
            },
            {
              "id": "SA-38",
              "question": "KCD warns against unnecessarily wrapping actions in `act()`. Explain what `act()` does, why RTL already handles it, and what happens when you add unnecessary `act()` wrappers.",
              "model_answer": "`act()` is a React testing utility that ensures all state updates and effects triggered by a piece of code are flushed and applied to the DOM before assertions run. RTL's `render`, `fireEvent`, and `user-event` already wrap their operations in `act()` internally, so adding another `act()` around them is redundant. Unnecessary `act()` wrappers clutter the test code, make it harder to read, and can mask real warnings — when React emits an \"act(...)\" warning, it is telling you that a state update happened outside of your test's control flow (often an unmocked async operation), which is a real issue worth investigating rather than silencing with a manual `act()` wrapper.",
              "tags": [
                "common-mistakes",
                "foundations"
              ]
            },
            {
              "id": "SA-39",
              "question": "Define the `rerender` function returned by RTL's `render`. When would you use it instead of rendering the component again?",
              "model_answer": "`rerender` takes a new React element and re-renders it into the same container as the original `render` call, simulating a parent component passing new props. It preserves the component's DOM node and React state between renders (unless the element type or key changes). You use it to test prop changes: render a component with initial props, assert initial state, call `rerender(<Component newProp={value} />)`, and assert the updated output. This is more accurate than calling `render` again, which would create a fresh mount, discarding any accumulated state.",
              "tags": [
                "rtl-utilities"
              ]
            },
            {
              "id": "SA-40",
              "question": "Explain the `name` option in `getByRole`. What types of values does it accept, and how does it match?",
              "model_answer": "The `name` option in `getByRole` filters elements by their accessible name. It accepts a string (exact match), a regular expression (partial/pattern match), or a function that receives the accessible name and returns a boolean. `getByRole('button', { name: 'Submit' })` matches a button whose accessible name is exactly \"Submit\". `getByRole('button', { name: /submit/i })` matches case-insensitively. The accessible name is computed from the element's text content, `aria-label`, `aria-labelledby`, associated `<label>`, or `title` attribute, following the W3C accessible name computation algorithm.",
              "tags": [
                "accessible-queries",
                "aria-roles"
              ]
            },
            {
              "id": "SA-41",
              "question": "What additional options does `getByRole` accept beyond `name`? Name three and describe what each filters on.",
              "model_answer": "Beyond `name`, `getByRole` accepts: (1) `checked` — filters checkboxes and radio buttons by their checked state (`true`, `false`): `getByRole('checkbox', { checked: true })`. (2) `selected` — filters options by their selected state: `getByRole('option', { selected: true })`. (3) `level` — filters headings by their level: `getByRole('heading', { level: 2 })` matches `<h2>` elements. Additional options include `pressed` (for toggle buttons), `expanded` (for accordion or collapsible elements), `hidden` (to include elements hidden from accessibility), and `current` (for current navigation items).",
              "tags": [
                "accessible-queries",
                "aria-roles"
              ]
            },
            {
              "id": "SA-42",
              "question": "Explain what `getByLabelText` queries and why it is ranked second in the priority hierarchy (after `getByRole`). When is it the better choice over `getByRole`?",
              "model_answer": "`getByLabelText` finds form elements by their associated label text — it looks for `<label>` elements whose text matches, then returns the labeled input. It is ranked second because labels are a primary way users (including screen reader users) identify form controls. It is sometimes a better choice than `getByRole` when multiple inputs have the same role (e.g., several `textbox` elements on a form) and filtering by `name` with `getByRole` is awkward. `getByLabelText('Email address')` is direct and readable. It also catches accessibility bugs: if the label is not correctly associated (missing `htmlFor`), the query fails, revealing the problem.",
              "tags": [
                "rtl-queries",
                "accessible-queries"
              ]
            },
            {
              "id": "SA-43",
              "question": "Define what `user.keyboard` does. Explain the syntax for special keys and give an example of simulating Ctrl+A.",
              "model_answer": "`user.keyboard()` simulates arbitrary keyboard input. Regular characters are typed as-is. Special keys are enclosed in curly braces: `{Enter}`, `{Escape}`, `{Backspace}`, `{ArrowDown}`, etc. Modifier keys are specified as held-down characters: `{Control>}` holds Control, and `{/Control}` releases it.\n\nSimulating Ctrl+A (select all): `await user.keyboard('{Control>}a{/Control}')`. This presses Control, then presses 'a' while Control is held, then releases Control. This is useful for testing keyboard shortcuts, form navigation, and accessibility features that depend on modifier key combinations.",
              "tags": [
                "user-event"
              ]
            },
            {
              "id": "SA-44",
              "question": "What does `getByDisplayValue` query, and when would you use it instead of `getByRole` or `getByLabelText`?",
              "model_answer": "`getByDisplayValue` finds input, textarea, or select elements by their current displayed value — the text the user sees in the field. You would use it when testing that a form field is pre-populated with specific data (e.g., on an edit page) or after user input to verify the value is displayed. It is useful when the input has no associated label (an accessibility problem, but sometimes present in legacy code) or when you specifically need to assert on the value rather than the label. Example: `screen.getByDisplayValue('alice@example.com')` finds the input currently showing that email address.",
              "tags": [
                "rtl-queries"
              ]
            },
            {
              "id": "SA-45",
              "question": "Explain the difference between `toHaveTextContent` and `getByText` in terms of what they check and when to use each.",
              "model_answer": "`getByText('Submit')` is a query — it finds an element in the DOM by its text content and returns the element. It is used to locate elements for interaction or further assertion. `toHaveTextContent('Submit')` is an assertion (a jest-dom matcher) — it checks whether an already-found element contains the specified text as part of its content. Use `getByText` when you need to find an element by its text. Use `toHaveTextContent` when you already have a reference to an element (found by role, label, etc.) and want to assert what text it displays. `toHaveTextContent` also supports partial matching and regex, and it normalizes whitespace by default.",
              "tags": [
                "jest-dom",
                "rtl-queries"
              ]
            },
            {
              "id": "SA-46",
              "question": "Define what `user.pointer` does and give a scenario where you would need it instead of `user.click`.",
              "model_answer": "`user.pointer` provides low-level pointer event simulation, giving you control over specific pointer interactions like hovering, pressing, releasing, and moving. While `user.click` simulates the full click sequence (down + up + click), `user.pointer` lets you decompose or customize these steps. You need it when testing hover-triggered behavior (like tooltips or dropdown menus) that responds to `pointerenter` or `mouseover` events — `user.click` would trigger the full click, but you just want the hover. Example: `await user.pointer({ target: element, keys: '[MouseLeft>]' })` presses the left mouse button without releasing it, useful for testing drag interactions.",
              "tags": [
                "user-event"
              ]
            },
            {
              "id": "SA-47",
              "question": "What is the purpose of the `hidden` option in `getByRole`? When would you set `hidden: true`?",
              "model_answer": "By default, `getByRole` only finds elements that are accessible to assistive technology — elements that are not hidden via `aria-hidden=\"true\"`, `display: none`, `visibility: hidden`, or the `hidden` attribute. The `hidden: true` option includes these hidden elements in the search. You would set `hidden: true` when testing a component that intentionally hides elements from assistive tech — for example, a modal backdrop, a visually-hidden skip-to-content link that only appears on focus, or a collapsed accordion panel. In general, needing `hidden: true` is rare and may indicate an accessibility issue worth investigating.",
              "tags": [
                "accessible-queries",
                "aria-roles"
              ]
            },
            {
              "id": "SA-48",
              "question": "Explain the concept of \"query scoping\" in RTL. What are the three levels at which queries can be scoped?",
              "model_answer": "Query scoping determines which portion of the DOM a query searches. The three levels are: (1) `screen` — queries are scoped to the entire `document.body`, which includes all rendered components. This is the default and most common scope. (2) `within(element)` — queries are scoped to a specific element's subtree, useful for disambiguating when multiple similar elements exist. (3) The return value of `render` — queries returned by `render()` are scoped to the component's container element. KCD recommends using `screen` over the render return for readability, and using `within` when you need finer scoping.",
              "tags": [
                "rtl-utilities"
              ]
            }
          ]
        },
        {
          "type": "multiple_choice",
          "count": 48,
          "questions": [
            {
              "id": "MC-1",
              "question": "RTL's guiding principle is:",
              "options": [
                "\"Test internals to catch bugs early\"",
                "\"The more your tests resemble the way your software is used, the more confidence they can give you\"",
                "\"Always mock child components for isolation\"",
                "\"Maximize code coverage for confidence\""
              ],
              "answer": 1,
              "explanation": "This is RTL's stated guiding principle: tests that resemble real usage give the most confidence.",
              "tags": [
                "rtl-philosophy",
                "foundations"
              ]
            },
            {
              "id": "MC-2",
              "question": "What is the recommended way to access queries in RTL tests?",
              "options": [
                "Destructure queries from `render()`: `const { getByText } = render(<App />)`",
                "Use the `screen` object: `screen.getByText(\"hello\")`",
                "Use `document.querySelector`",
                "Access the component instance directly"
              ],
              "answer": 1,
              "explanation": "`screen` is the recommended way to access queries. Destructuring from `render` is listed by KCD as a common mistake.",
              "tags": [
                "rtl-queries",
                "rtl-utilities",
                "common-mistakes"
              ]
            },
            {
              "id": "MC-3",
              "question": "Which query should you try first when looking for a button?",
              "options": [
                "`getByText(\"Submit\")`",
                "`getByTestId(\"submit-button\")`",
                "`getByRole('button', { name: /submit/i })`",
                "`document.querySelector('button')`"
              ],
              "answer": 2,
              "explanation": "`getByRole` is the highest-priority query. `getByRole('button', { name: /submit/i })` queries by role and accessible name.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles",
                "foundations"
              ]
            },
            {
              "id": "MC-4",
              "question": "Which query is best for finding a text input with a visible label \"Email Address\"?",
              "options": [
                "`getByTestId(\"email-input\")`",
                "`getByPlaceholderText(\"Email Address\")`",
                "`getByLabelText(\"Email Address\")`",
                "`getByRole('input')`"
              ],
              "answer": 2,
              "explanation": "`getByLabelText` is the best query for form fields with visible labels. It mimics how users find form controls.",
              "tags": [
                "rtl-queries",
                "accessible-queries"
              ]
            },
            {
              "id": "MC-5",
              "question": "`getByTestId` should be used:",
              "options": [
                "As the default query for all elements",
                "For interactive elements like buttons",
                "As a last resort when no semantic query works",
                "For all form inputs"
              ],
              "answer": 2,
              "explanation": "`getByTestId` is a last resort when no accessible or semantic query works. It has no meaning to users.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "foundations"
              ]
            },
            {
              "id": "MC-6",
              "question": "What does `getByRole('heading', { level: 2 })` match?",
              "options": [
                "Any element with `role=\"heading\"`",
                "An `<h2>` element",
                "Any heading element (`<h1>` through `<h6>`)",
                "An element with `aria-level=\"2\"`"
              ],
              "answer": 1,
              "explanation": "`getByRole('heading', { level: 2 })` specifically matches `<h2>` elements (role `heading`, level 2).",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles"
              ]
            },
            {
              "id": "MC-7",
              "question": "What is the implicit ARIA role of a single-select `<select>` element?",
              "options": [
                "`select`",
                "`dropdown`",
                "`combobox`",
                "`listbox`"
              ],
              "answer": 2,
              "explanation": "A single-select `<select>` element (no `multiple` attribute, no `size > 1`) has the implicit ARIA role `combobox`. A `<select>` with `multiple` or `size > 1` has the role `listbox`.",
              "tags": [
                "accessible-queries",
                "aria-roles"
              ]
            },
            {
              "id": "MC-8",
              "question": "What does `getBy` do when no matching element is found?",
              "options": [
                "Returns `null`",
                "Returns an empty array",
                "Throws an error",
                "Returns `undefined`"
              ],
              "answer": 2,
              "explanation": "`getBy` throws an error when no match is found, causing the test to fail with a descriptive message.",
              "tags": [
                "rtl-queries",
                "foundations"
              ]
            },
            {
              "id": "MC-9",
              "question": "What does `queryBy` do when no matching element is found?",
              "options": [
                "Throws an error",
                "Returns `null`",
                "Returns `undefined`",
                "Returns `false`"
              ],
              "answer": 1,
              "explanation": "`queryBy` returns `null` when no match is found, which is safe for negative assertions.",
              "tags": [
                "rtl-queries",
                "foundations"
              ]
            },
            {
              "id": "MC-10",
              "question": "When should you use `queryBy` instead of `getBy`?",
              "options": [
                "When the element might appear asynchronously",
                "When asserting that an element does NOT exist in the DOM",
                "When querying multiple elements",
                "When the element has no accessible name"
              ],
              "answer": 1,
              "explanation": "`queryBy` is used when asserting absence: `expect(screen.queryByText(\"X\")).not.toBeInTheDocument()`.",
              "tags": [
                "rtl-queries",
                "jest-dom",
                "foundations"
              ]
            },
            {
              "id": "MC-11",
              "question": "`findBy` queries are most useful when:",
              "options": [
                "The element is already in the DOM",
                "The element will appear asynchronously after some state change or data fetch",
                "You want to find multiple elements",
                "You want to assert the element does not exist"
              ],
              "answer": 1,
              "explanation": "`findBy` is for elements that appear asynchronously. It returns a Promise that resolves when the element appears.",
              "tags": [
                "rtl-queries",
                "async-testing",
                "foundations"
              ]
            },
            {
              "id": "MC-12",
              "question": "`findBy` returns:",
              "options": [
                "The element immediately",
                "`null` if not found",
                "A Promise that resolves when the element appears",
                "An array of elements"
              ],
              "answer": 2,
              "explanation": "`findBy` returns a Promise. You must `await` it.",
              "tags": [
                "rtl-queries",
                "async-testing"
              ]
            },
            {
              "id": "MC-13",
              "question": "What does `getAllByRole('listitem')` return?",
              "options": [
                "The first `<li>` element found",
                "An array of all elements with the `listitem` role",
                "A Promise resolving to an array",
                "`null` if no items are found"
              ],
              "answer": 1,
              "explanation": "`getAllBy` returns an array of all matching elements.",
              "tags": [
                "rtl-queries",
                "aria-roles"
              ]
            },
            {
              "id": "MC-14",
              "question": "What happens when `getAllBy` finds no matching elements?",
              "options": [
                "Returns an empty array",
                "Returns `null`",
                "Throws an error",
                "Returns `undefined`"
              ],
              "answer": 2,
              "explanation": "`getAllBy` throws if no elements are found. Use `queryAllBy` if an empty array is acceptable.",
              "tags": [
                "rtl-queries"
              ]
            },
            {
              "id": "MC-15",
              "question": "What is the difference between `fireEvent.click(element)` and `user.click(element)`?",
              "options": [
                "They are identical",
                "`fireEvent.click` dispatches only the `click` event; `user.click` fires the full pointer/mouse/click sequence",
                "`user.click` is synchronous; `fireEvent.click` is async",
                "`fireEvent.click` works on all elements; `user.click` only works on buttons"
              ],
              "answer": 1,
              "explanation": "`fireEvent.click` dispatches only `click`. `user.click` fires the full pointer/mouse/focus/click sequence.",
              "tags": [
                "user-event",
                "common-mistakes",
                "foundations"
              ]
            },
            {
              "id": "MC-16",
              "question": "How do you set up `user-event` in a test?",
              "options": [
                "`import user from '@testing-library/user-event'`",
                "`const user = userEvent.setup()` at the beginning of the test or `beforeEach`",
                "`const user = new UserEvent()`",
                "`fireEvent.enableUserEvents()`"
              ],
              "answer": 1,
              "explanation": "`const user = userEvent.setup()` creates a user instance with proper event coordination. This is the recommended pattern.",
              "tags": [
                "user-event",
                "foundations"
              ]
            },
            {
              "id": "MC-17",
              "question": "`user.type(element, \"hello\")` simulates:",
              "options": [
                "Setting the input's value property directly to \"hello\"",
                "Typing \"hello\" character by character, firing keyboard events for each character",
                "Pasting \"hello\" into the input",
                "Calling `element.setAttribute(\"value\", \"hello\")`"
              ],
              "answer": 1,
              "explanation": "`user.type` simulates character-by-character input with all associated keyboard events.",
              "tags": [
                "user-event"
              ]
            },
            {
              "id": "MC-18",
              "question": "Which `user-event` method clears the current value of an input field?",
              "options": [
                "`user.delete(element)`",
                "`user.clear(element)`",
                "`user.reset(element)`",
                "`user.empty(element)`"
              ],
              "answer": 1,
              "explanation": "`user.clear(element)` clears the input's value.",
              "tags": [
                "user-event"
              ]
            },
            {
              "id": "MC-19",
              "question": "`user-event` methods are:",
              "options": [
                "Synchronous — they resolve immediately",
                "Asynchronous — they return Promises and should be awaited",
                "Some are sync and some are async",
                "Only async in strict mode"
              ],
              "answer": 1,
              "explanation": "All `user-event` methods return Promises and should be awaited.",
              "tags": [
                "user-event",
                "async-testing"
              ]
            },
            {
              "id": "MC-20",
              "question": "`user.tab()` simulates:",
              "options": [
                "Opening a new browser tab",
                "Inserting a tab character",
                "Pressing the Tab key to move focus to the next focusable element",
                "Indenting text"
              ],
              "answer": 2,
              "explanation": "`user.tab()` simulates pressing the Tab key to move focus.",
              "tags": [
                "user-event"
              ]
            },
            {
              "id": "MC-21",
              "question": "`user.selectOptions(select, ['value1'])` is used for:",
              "options": [
                "Selecting text in an input",
                "Selecting an option from a `<select>` dropdown or listbox",
                "Checking checkboxes",
                "Choosing radio buttons"
              ],
              "answer": 1,
              "explanation": "`user.selectOptions` simulates selecting options from a `<select>` or listbox.",
              "tags": [
                "aria-roles",
                "user-event"
              ]
            },
            {
              "id": "MC-22",
              "question": "What does `waitFor` do?",
              "options": [
                "Waits for a specified number of milliseconds",
                "Repeatedly calls the provided callback until it stops throwing or the timeout is reached",
                "Pauses the test execution",
                "Waits for all Promises to resolve"
              ],
              "answer": 1,
              "explanation": "`waitFor` repeatedly invokes the callback on an interval until it stops throwing or times out.",
              "tags": [
                "async-testing"
              ]
            },
            {
              "id": "MC-23",
              "question": "What is the advantage of using `findBy` over `waitFor` + `getBy`?",
              "options": [
                "`findBy` is faster",
                "`findBy` combines the wait-and-query into a single, more readable call",
                "`findBy` works without a DOM",
                "`findBy` never times out"
              ],
              "answer": 1,
              "explanation": "`findBy` is a single, readable call that combines waiting and querying. It is preferred over the more verbose `waitFor` + `getBy`.",
              "tags": [
                "rtl-queries",
                "async-testing"
              ]
            },
            {
              "id": "MC-24",
              "question": "`waitForElementToBeRemoved` is used to:",
              "options": [
                "Remove an element from the DOM",
                "Wait until a queried element is no longer present in the DOM",
                "Delete a component from memory",
                "Unmount a component"
              ],
              "answer": 1,
              "explanation": "`waitForElementToBeRemoved` waits until the element is gone from the DOM.",
              "tags": [
                "async-testing"
              ]
            },
            {
              "id": "MC-25",
              "question": "Should you manually wrap RTL calls in `act()`?",
              "options": [
                "Yes, always",
                "No — `render` and `user-event` already handle `act()` internally",
                "Only for async operations",
                "Only for class components"
              ],
              "answer": 1,
              "explanation": "RTL handles `act()` internally. Manual `act()` is unnecessary and is a common mistake per KCD.",
              "tags": [
                "rtl-utilities",
                "common-mistakes",
                "foundations"
              ]
            },
            {
              "id": "MC-26",
              "question": "`screen.debug()` prints:",
              "options": [
                "The component's props and state",
                "The current DOM tree to the console",
                "A list of all available queries",
                "The React fiber tree"
              ],
              "answer": 1,
              "explanation": "`screen.debug()` prints the DOM tree to the console for debugging.",
              "tags": [
                "rtl-queries",
                "rtl-utilities"
              ]
            },
            {
              "id": "MC-27",
              "question": "`logRoles(container)` is useful for:",
              "options": [
                "Logging all event handlers on an element",
                "Discovering which ARIA roles are present in the rendered DOM, helping you write `getByRole` queries",
                "Printing the component hierarchy",
                "Listing all CSS classes"
              ],
              "answer": 1,
              "explanation": "`logRoles` prints all ARIA roles in the container, helping you discover correct roles for `getByRole`.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles",
                "rtl-utilities"
              ]
            },
            {
              "id": "MC-28",
              "question": "The `within` function:",
              "options": [
                "Limits a test to a specific time window",
                "Scopes queries to a specific container element",
                "Creates a new `describe` block",
                "Filters test files"
              ],
              "answer": 1,
              "explanation": "`within` scopes queries to a specific container element.",
              "tags": [
                "rtl-utilities"
              ]
            },
            {
              "id": "MC-29",
              "question": "What does the `wrapper` option in `render` do?",
              "options": [
                "Wraps the test function in a try/catch",
                "Wraps the rendered component in a specified provider component (e.g., ThemeProvider)",
                "Wraps the DOM in a shadow root",
                "Wraps the component in React.StrictMode"
              ],
              "answer": 1,
              "explanation": "The `wrapper` option wraps the rendered component in a provider (e.g., ThemeProvider, Router).",
              "tags": [
                "rtl-utilities"
              ]
            },
            {
              "id": "MC-30",
              "question": "Which of the following is a \"Common Mistake\" identified by KCD?",
              "options": [
                "Using `screen` to access queries",
                "Using `getByRole` as the primary query",
                "Destructuring queries from `render` instead of using `screen`",
                "Using `user-event` instead of `fireEvent`"
              ],
              "answer": 2,
              "explanation": "KCD identifies destructuring from `render` instead of using `screen` as a common mistake.",
              "tags": [
                "rtl-queries",
                "rtl-utilities",
                "common-mistakes"
              ]
            },
            {
              "id": "MC-31",
              "question": "Another common mistake identified by KCD is:",
              "options": [
                "Using `findBy` for async elements",
                "Unnecessarily wrapping things in `act()`",
                "Using `getByLabelText` for form inputs",
                "Awaiting `user-event` methods"
              ],
              "answer": 1,
              "explanation": "Unnecessarily wrapping things in `act()` is another mistake KCD identifies. RTL handles `act()` for you.",
              "tags": [
                "rtl-utilities",
                "common-mistakes"
              ]
            },
            {
              "id": "MC-32",
              "question": "KCD recommends using `findBy` instead of:",
              "options": [
                "`getBy`",
                "`queryBy`",
                "`waitFor` + `getBy` for waiting for elements to appear",
                "`getAllBy`"
              ],
              "answer": 2,
              "explanation": "KCD recommends `findBy` over the `waitFor` + `getBy` pattern for waiting for elements to appear.",
              "tags": [
                "rtl-queries",
                "async-testing",
                "common-mistakes"
              ]
            },
            {
              "id": "MC-33",
              "question": "What is the correct way to assert that an element is NOT in the DOM?",
              "options": [
                "`expect(screen.getByText(\"Error\")).not.toBeInTheDocument()`",
                "`expect(screen.queryByText(\"Error\")).not.toBeInTheDocument()`",
                "`expect(screen.findByText(\"Error\")).not.toBeInTheDocument()`",
                "`expect(screen.getByText(\"Error\")).toBeNull()`"
              ],
              "answer": 1,
              "explanation": "`queryByText` returns `null` when not found, allowing `.not.toBeInTheDocument()`. `getByText` would throw first.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "jest-dom",
                "foundations"
              ]
            },
            {
              "id": "MC-34",
              "question": "Where does `.toBeInTheDocument()` come from?",
              "options": [
                "It is built into Vitest",
                "It is built into RTL",
                "It comes from `@testing-library/jest-dom`, which must be imported in a setup file",
                "It comes from `jsdom`"
              ],
              "answer": 2,
              "explanation": "`.toBeInTheDocument()` is a custom matcher from `@testing-library/jest-dom`. It must be imported (usually via `setupFiles`).",
              "tags": [
                "jest-dom",
                "foundations"
              ]
            },
            {
              "id": "MC-35",
              "question": "`getByText(/submit/i)` uses the `i` flag in the regex to:",
              "options": [
                "Make the match case-sensitive",
                "Make the match case-insensitive",
                "Enable multiline matching",
                "Match only the first character"
              ],
              "answer": 1,
              "explanation": "The `i` flag in regex makes the match case-insensitive.",
              "tags": [
                "rtl-queries",
                "accessible-queries"
              ]
            },
            {
              "id": "MC-36",
              "question": "`getByText(\"Submit\")` with default options will match:",
              "options": [
                "Any element containing \"Submit\" as a substring",
                "Only an element whose entire text content is exactly \"Submit\"",
                "Any element with \"Submit\" in its `value` attribute",
                "Only `<button>` elements with \"Submit\" text"
              ],
              "answer": 1,
              "explanation": "`getByText(\"Submit\")` does an exact, full-content match by default. Substring matches require `{ exact: false }` or regex.",
              "tags": [
                "rtl-queries",
                "accessible-queries"
              ]
            },
            {
              "id": "MC-37",
              "question": "To make `getByText` perform a substring match, you can:",
              "options": [
                "Pass `{ exact: false }` as the second argument",
                "Pass `{ partial: true }`",
                "Use `getByTextContaining` instead",
                "You cannot; use regex instead"
              ],
              "answer": 0,
              "explanation": "`{ exact: false }` enables substring matching. Alternatively, you can use regex: `getByText(/Submit/)`.",
              "tags": [
                "rtl-queries",
                "accessible-queries"
              ]
            },
            {
              "id": "MC-38",
              "question": "What is the accessible name of this button?",
              "options": [
                "`\"button\"`",
                "`\"Save Changes\"`",
                "`\"save-changes\"`",
                "It has no accessible name"
              ],
              "answer": 1,
              "explanation": "The accessible name of a `<button>` is derived from its text content: `\"Save Changes\"`.",
              "tags": [
                "accessible-queries",
                "aria-roles"
              ],
              "code": "```tsx\n<button>Save Changes</button>\n```"
            },
            {
              "id": "MC-39",
              "question": "What is the accessible name of this input?",
              "options": [
                "`\"email\"`",
                "`\"Email Address\"`",
                "`\"text\"`",
                "`\"textbox\"`"
              ],
              "answer": 1,
              "explanation": "The `<label htmlFor=\"email\">Email Address</label>` associates with the input, giving it the accessible name `\"Email Address\"`.",
              "tags": [
                "accessible-queries"
              ],
              "code": "```tsx\n<label htmlFor=\"email\">Email Address</label>\n<input id=\"email\" type=\"text\" />\n```"
            },
            {
              "id": "MC-40",
              "question": "Which query finds the input in MC-39?",
              "options": [
                "`getByRole('textbox', { name: /email address/i })`",
                "`getByRole('input', { name: /email/i })`",
                "`getByTestId(\"email\")`",
                "`getByRole('textbox', { id: 'email' })`"
              ],
              "answer": 0,
              "explanation": "The input has role `textbox` and accessible name `\"Email Address\"` from its label. `getByRole('textbox', { name: /email address/i })` matches.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles"
              ]
            },
            {
              "id": "MC-41",
              "question": "`user.keyboard('{Enter}')` simulates:",
              "options": [
                "Typing the literal text \"{Enter}\"",
                "Pressing the Enter key",
                "Submitting a form",
                "Creating a new line"
              ],
              "answer": 1,
              "explanation": "`{Enter}` in `user.keyboard` is a special key notation that simulates pressing the Enter key.",
              "tags": [
                "user-event"
              ]
            },
            {
              "id": "MC-42",
              "question": "`user.type(input, \"abc{backspace}\")` results in:",
              "options": [
                "`\"abc{backspace}\"` as the input value",
                "`\"ab\"` as the input value (types \"abc\" then deletes the last character)",
                "`\"abcBackspace\"` as the input value",
                "An error because `{backspace}` is not valid"
              ],
              "answer": 1,
              "explanation": "`user.type` processes `{backspace}` as a special key. After typing \"abc\", Backspace deletes \"c\", leaving \"ab\".",
              "tags": [
                "user-event"
              ]
            },
            {
              "id": "MC-43",
              "question": "RTL automatically cleans up after each test by:",
              "options": [
                "Deleting all test files",
                "Unmounting rendered components and clearing the DOM",
                "Resetting the JavaScript runtime",
                "Restarting the test environment"
              ],
              "answer": 1,
              "explanation": "RTL auto-cleanup unmounts rendered components and clears the DOM after each test.",
              "tags": [
                "rtl-utilities"
              ]
            },
            {
              "id": "MC-44",
              "question": "A test needs to check that a tooltip appears when hovering over a button. Which `user-event` method should be used?",
              "options": [
                "`user.click(button)`",
                "`user.hover(button)`",
                "`user.mouseOver(button)`",
                "`user.focus(button)`"
              ],
              "answer": 1,
              "explanation": "`user.hover(button)` simulates mouse hover, which would trigger tooltip display.",
              "tags": [
                "aria-roles",
                "user-event"
              ]
            },
            {
              "id": "MC-45",
              "question": "The `<img alt=\"User avatar\">` element can be found with:",
              "options": [
                "`getByRole('img', { name: /user avatar/i })`",
                "`getByAltText(/user avatar/i)`",
                "Both (a) and (b)",
                "Neither — images cannot be queried"
              ],
              "answer": 2,
              "explanation": "Both work. `<img>` has role `img` and the `alt` text provides the accessible name. `getByAltText` also targets `alt` text.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles"
              ]
            },
            {
              "id": "MC-46",
              "question": "A `<nav>` element has the implicit ARIA role:",
              "options": [
                "`navigation`",
                "`nav`",
                "`menu`",
                "`region`"
              ],
              "answer": 0,
              "explanation": "`<nav>` has the implicit ARIA role `navigation`.",
              "tags": [
                "accessible-queries",
                "aria-roles"
              ]
            },
            {
              "id": "MC-47",
              "question": "Which query would you use to find a `<textarea>` with a label \"Description\"?",
              "options": [
                "`getByRole('textarea', { name: /description/i })`",
                "`getByRole('textbox', { name: /description/i })`",
                "`getByLabelText(/description/i)`",
                "Both (b) and (c) work"
              ],
              "answer": 3,
              "explanation": "Both work. `<textarea>` has role `textbox`, so `getByRole('textbox', { name: /description/i })` works. `getByLabelText(/description/i)` also finds it via label.",
              "tags": [
                "rtl-queries",
                "accessible-queries",
                "aria-roles"
              ]
            },
            {
              "id": "MC-48",
              "question": "`queryAllByRole('listitem')` returns what when there are no `<li>` elements?",
              "options": [
                "Throws an error",
                "Returns `null`",
                "Returns an empty array `[]`",
                "Returns `undefined`"
              ],
              "answer": 2,
              "explanation": "`queryAllBy` returns an empty array `[]` when no matches are found, rather than throwing.",
              "tags": [
                "rtl-queries",
                "aria-roles"
              ]
            }
          ]
        }
      ]
    }
  ]
}